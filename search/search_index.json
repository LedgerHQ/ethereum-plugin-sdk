{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ethereum plugin documentation","text":"<p>This documentation will help you design your own ethereum plugin.</p>"},{"location":"#what-is-a-plugin","title":"What is a plugin?","text":"<p>A plugin is a lightweight application that only performs smart contract parsing and leverages the Ethereum application for the rest.</p> <p>Your plugin will allow your users to clear-sign your smart contracts when using a Ledger device.</p> <p>Plugins are designed to work hand-in-hand with the Ethereum application:</p> <ul> <li>The plugin handle the smart contract parsing</li> <li>The Ethereum application handles everything else (APDU reception, signature, screen management, bluetooth, etc)</li> </ul> <p>Upon your smart contract reception, the Ethereum application will call your plugin to query the elements to display and your plugin will be responsible for:</p> <ul> <li>Extracting the relevant information from the smart contract.</li> <li>Replying the string to be displayed back to the Ethereum App.</li> </ul>"},{"location":"#coding-my-own-plugin","title":"Coding my own plugin","text":""},{"location":"#use-the-ethereum-plugin-sdk","title":"Use the Ethereum Plugin SDK","text":"<p>Use the Ledger developed Ethereum Plugin SDK. The SDK will do all the busy work of your plugin and leave you with only a few handlers to code. The SDK is designed to be used as a git submodule.</p> <p>Note</p> <p>Always keep your SDK up to date with its develop branch. We are providing a CI workflow to help you check that the latest version is being used.</p>"},{"location":"#fork-the-plugin-boilerplate","title":"Fork the Plugin Boilerplate","text":"<p>While starting a new plugin application from a blank repository + the SDK is technically possible, it is not at all recommended and support would not be provided. Instead, fork our official template application Plugin Boilerplate and start from there.</p> <p>You will start with a correct build structure, examples of handlers, our test framework working, and the CI workflows already setup.</p>"},{"location":"#plugin-file-structure","title":"Plugin file structure","text":"<ul> <li><code>.github/workflows</code>: the CI workflows required to showcase your plugin's quality.</li> <li><code>Makefile</code>: The entry point of the compilation of your plugin.</li> <li><code>PLUGIN_SPECIFICATION.md</code>: The specification of the supported smart-contract and selectors of your plugin.</li> <li><code>ethereum-plugin-sdk/</code>: This repository contains the interface between the Ethereum app and your plugin, as well as a lot of utility functions.</li> <li><code>fuzzing/</code>: the Fuzzer folder.</li> <li><code>glyphs/</code>: The icon displayed by the Ethereum application when using the plugin on a Touchscreen device.</li> <li><code>icons/</code>: The icons displayed on the device dashboard on any device.</li> <li><code>ledger_app.toml</code>: the Manifest of your plugin, used to bridge with the Ledger developed tools.</li> <li><code>src/</code>: the source code of the plugin (in C).</li> <li><code>tests/</code>: the tests folder.</li> </ul>"},{"location":"technical_informations/","title":"Technical Informations","text":"<p>Please find in this section technical information helpful for coding your plugin.</p> <p>Only technical information specific to plugin development are written here.</p>"},{"location":"technical_informations/diagram/","title":"Sequence diagram","text":"<p>This diagram showcases a complete sequence of the parsing, display, and signature of a smart contract.</p> <pre><code>sequenceDiagram\n    participant L as Ledger Live\n    participant E as Ethereum application\n    participant SDK as Plugin SDK\n    participant P as Plugin\n    L-&gt;&gt;E: SET_EXTERNAL_PLUGIN\n    E-&gt;&gt;+SDK: ETH_PLUGIN_CHECK_PRESENCE\n    SDK-&gt;&gt;-E: ack;\n    L-&gt;&gt;+E: Transaction to sign\n    Note over E: The plugin for this smart&lt;br/&gt;contract exists, rely on it\n    E-&gt;&gt;+SDK: ETH_PLUGIN_INITIALIZE\n    SDK-&gt;&gt;+P: handle_init_contract()\n    Note over P: Your code here\n    P-&gt;&gt;-SDK: return;\n    SDK-&gt;&gt;-E: ;\n    Note over E: Split contract data in chunks\n    loop Send smart contract chunks\n        E-&gt;&gt;+SDK: ETH_PLUGIN_PROVIDE_PARAMETER\n        SDK-&gt;&gt;+P: handle_provide_parameter()\n        Note over P: Your code here\n        P-&gt;&gt;-SDK: return;\n        SDK-&gt;&gt;-E: ;\n    end\n    Note over E: Inform plugin that everything was sent\n    E-&gt;&gt;+SDK: ETH_PLUGIN_FINALIZE\n    SDK-&gt;&gt;+P: handle_finalize()\n    Note over P: Your code here\n    P-&gt;&gt;-SDK: Number of screens needed&lt;br/&gt;Ask ERC20 tokens info if needed\n    SDK-&gt;&gt;-E: ;\n    opt\n        Note over L: Knows that Ethereum&lt;br/&gt;will need ERC20 token info\n        L-&gt;&gt;E: Provide ERC20 token\n        E-&gt;&gt;+SDK: ETH_PLUGIN_PROVIDE_TOKEN\n        SDK-&gt;&gt;+P: handle_provide_token()\n        Note over P: Your code here\n        P-&gt;&gt;-SDK: Update screens number\n        SDK-&gt;&gt;-E: ;\n    end\n    Note over E: Ready to start display\n    E-&gt;&gt;+SDK: ETH_PLUGIN_QUERY_CONTRACT_ID\n    SDK-&gt;&gt;+P: handle_query_contract_id()\n    Note over P: Your code here\n    P-&gt;&gt;-SDK: Provide title screen\n    SDK-&gt;&gt;-E: ;\n    loop For every screen requested\n        E-&gt;&gt;+SDK: ETH_PLUGIN_QUERY_CONTRACT_UI\n        SDK-&gt;&gt;+P: handle_query_contract_ui()\n        Note over P: Your code here\n        P-&gt;&gt;-SDK: Provide screen\n        SDK-&gt;&gt;-E: ;\n    end\n    Note over E: User validates or rejects\n    E-&gt;&gt;-L: Transaction signed / rejected</code></pre>"},{"location":"technical_informations/globals/","title":"Global variables and semi-persistent memory","text":"<p>Warning</p> <p>Global variables should never be used in your plugin. Only the semi-persistent context provided by the Ethereum application should be used.</p> <p>Each call by the Ethereum application starts the plugin anew with a fresh main call: everything not saved in the context is lost.</p> <p>In order to retain knowledge from a handler call to another, the plugin can use a memory section allocated by the Ethereum application.</p> <p>The context can be accessed through the <code>uint8_t *pluginContext</code> field of the parameter. All handlers will pass it to your plugin and it's common to your plugin's lifetime from the init call to the display.</p> <p>The ethereum application will never modify the content of the structure.</p> <p>This is the size available for the context of your plugin: <pre><code>// Plugin-only memory allocated by the Ethereum application and used by the\n// plugin. 1k memory is available.\n#define PLUGIN_CONTEXT_SIZE (32 * INT256_LENGTH)\n</code></pre></p>"},{"location":"technical_informations/tx_content/","title":"Transaction data","text":"<p>Transaction data are provided to the plugin by the Ethereum application through the <code>txContent_t</code> structure.</p> <p>This structure is provided in every handler.</p> <pre><code>typedef struct txInt256_t {\n    uint8_t value[INT256_LENGTH];\n    uint8_t length;\n} txInt256_t;\n\ntypedef struct txContent_t {\n    txInt256_t gasprice;  // Used as MaxFeePerGas when dealing with EIP1559\n                          // transactions.\n    txInt256_t startgas;  // Also known as `gasLimit`.\n    txInt256_t value;\n    txInt256_t nonce;\n    txInt256_t chainID;\n    uint8_t destination[ADDRESS_LENGTH];\n    uint8_t destinationLength;\n    uint8_t v[8];\n    uint8_t vLength;\n    bool dataPresent;\n} txContent_t;\n</code></pre>"},{"location":"technical_informations/handlers/","title":"Handlers","text":"<p>Handlers are callbacks that the Ethereum application calls through the Ethereum plugin SDK to parse and display a smart contract. </p> <p>This is the list of all handlers that each plugin must define: <pre><code>// Functions to implement in the plugin\nvoid handle_init_contract(ethPluginInitContract_t *parameters);\nvoid handle_provide_parameter(ethPluginProvideParameter_t *parameters);\nvoid handle_finalize(ethPluginFinalize_t *parameters);\nvoid handle_provide_token(ethPluginProvideInfo_t *parameters);\nvoid handle_query_contract_id(ethQueryContractID_t *parameters);\nvoid handle_query_contract_ui(ethQueryContractUI_t *parameters);\n</code></pre></p> <p>Please look at the sequence diagram to better understand at which step each handler is called.</p>"},{"location":"technical_informations/handlers/handle_finalize/","title":"handle_finalize()","text":""},{"location":"technical_informations/handlers/handle_finalize/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call this handle when the entire smart contract has been fed to the plugin using the provide_parameter handle.</p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Check that nothing is missing from the smart contract if applicable.</li> <li>Report an error to the ethereum application if the smart contract has an issue.</li> <li>Request information about a ERC20 token if needed (2 max).</li> <li>Set the UI layout to SIMPLIFIED (called <code>UI_AMOUNT_ADDRESS</code>) or CUSTOM (called <code>ETH_UI_TYPE_GENERIC</code>)<ul> <li>CUSTOM: Inform the Ethereum application of the number of screens needed to display the smart contract.</li> <li>SIMPLIFIED: Inform the Ethereum application of the amount and address to display.</li> </ul> </li> </ul> <p>An example of smart contract parsing finalization is already done in the boilerplate plugin. Adapt and expand it for your use case.</p>"},{"location":"technical_informations/handlers/handle_finalize/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethPluginFinalize_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext; // PLUGIN_CONTEXT_SIZE\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. The plugin can set this value to a 20 bytes array in\n    // pluginContext containing the address of an ERC20 token. In this case\n    // Ethereum will call the plugin with handle_provide_token() with the\n    // requested ERC20 token information. The Ethereum application must be made\n    // aware of ERC20 token information first using 'PROVIDE ERC 20 TOKEN\n    // INFORMATION' APDU. Leave the value at NULL if not needed\n    const uint8_t *tokenLookup1;\n    // OUTPUT. Same as tokenLookup1.\n    const uint8_t *tokenLookup2;\n    // Reminder: const applies to the pointed memory area, which means the plugin\n    // can set the value and ethereum will modify the pointed value.\n\n    // OUTPUT. The plugin needs to set this value to either\n    // ETH_UI_TYPE_AMOUNT_ADDRESS for an amount/address UI or\n    // ETH_UI_TYPE_GENERIC for a generic UI.\n    eth_ui_type_t uiType;\n    union {\n        // OUTPUT. The plugin needs to set this pointer to a 256 bits number in\n        // pluginContext to display as the amount in UI_AMOUNT_ADDRESS case.\n        // IGNORED if uiType is UI_TYPE_GENERIC.\n        const uint8_t *amount;\n        // OUTPUT. The plugin needs to set this value to the number of screens\n        // needed to display the smart contract in ETH_UI_TYPE_GENERIC case.\n        // IGNORED if uiType is UI_AMOUNT_ADDRESS.\n        uint8_t numScreens;\n    };\n    // OUTPUT. The plugin needs to set this pointer to a 20 bytes address in\n    // pluginContext to display as the address in UI_AMOUNT_ADDRESS case.\n    // Set to the user's address if uiType is UI_TYPE_GENERIC\n    const uint8_t *address;  // set a pointer to the destination address (in pluginContext) if uiType is UI_AMOUNT_ADDRESS.\n\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    // - ETH_PLUGIN_RESULT_FALLBACK : if the signing logic should fallback to\n    // the generic one\n    eth_plugin_result_t result;\n\n} ethPluginFinalize_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_init_contract/","title":"handle_init_contract()","text":""},{"location":"technical_informations/handlers/handle_init_contract/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call the plugin using this handle upon reception of a smart contract that the plugin is supposed to know how to parse.</p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Check that the selector is recognized</li> <li>Initialize the fields of its context structure</li> </ul> <p>Most of this logic is already done in the boilerplate plugin. You just need to adapt for your use case.</p>"},{"location":"technical_informations/handlers/handle_init_contract/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethPluginInitContract_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Used to check that `ETH_PLUGIN_INTERFACE_VERSION_LATEST` is\n    // correct.\n    eth_plugin_interface_version_t interfaceVersion;\n\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n\n    // INPUT. Size of context allocated by the Ethereum application, must be\n    // equal to PLUGIN_CONTEXT_SIZE.\n    size_t pluginContextLength;\n\n    // INPUT. Selector of the smart contract that Ethereum application is asking\n    // te plugin to display.\n    const uint8_t *selector;\n\n    // INPUT. Total length of the data to come.\n    size_t dataSize;\n    bip32_path_t *bip32;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext;\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    // - ETH_PLUGIN_RESULT_FALLBACK : if the signing logic should fallback to\n    // the generic one\n    eth_plugin_result_t result;\n\n} ethPluginInitContract_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_provide_parameter/","title":"handle_provide_parameter()","text":""},{"location":"technical_informations/handlers/handle_provide_parameter/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call the plugin repeatidly using this handle to feed it the entire smart contract data parameter by parameter.</p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Read all parameters and keep track of the smart contract parsing progression</li> <li>Check that the values received are valid/possible when applicable</li> <li>Store in the context the data that will need to be displayed on screen.</li> <li>Report an error to the ethereum application if the smart contract has an issue.</li> </ul> <p>An example of smart contract parsing is already done in the boilerplate plugin. Adapt and expand it for your use case.</p>"},{"location":"technical_informations/handlers/handle_provide_parameter/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethPluginProvideParameter_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n\n    // INPUT. Pointer to the 32 bytes parameter being parsed in the smart\n    // contract data.\n    const uint8_t *parameter;\n\n    // INPUT. Offset to this parameter from the beginning of the data field\n    // (starts at 4, following the selector).\n    uint32_t parameterOffset;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext; // PLUGIN_CONTEXT_SIZE\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    // - ETH_PLUGIN_RESULT_FALLBACK : if the signing logic should fallback to\n    // the generic one\n    eth_plugin_result_t result;\n\n    // INPUT. Size of the parameter, usually 32 but can also be less for the\n    // last one.\n    uint8_t parameter_size;\n} ethPluginProvideParameter_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_provide_token/","title":"handle_provide_token()","text":""},{"location":"technical_informations/handlers/handle_provide_token/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call this handle when the plugin has requested ERC20 token information in <code>handle_finalize</code></p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Check that provided token matches the one requested.</li> <li>Increase the number of screens needed for the display if needed.</li> <li>Report an error to the ethereum application if the display must be aborted.</li> </ul> <p>Warning</p> <p>The Ethereum application can only provide to the plugin information about ERC20 token it knows about. You need to provide the ERC20 token information to the Ethereum application using <code>PROVIDE ERC 20 TOKEN INFORMATION</code> APDU.</p> <p>An example of token info providing is already done in the boilerplate plugin. Adapt and expand it for your use case.</p>"},{"location":"technical_informations/handlers/handle_provide_token/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethPluginProvideInfo_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n\n    // INPUT. ERC20 token information as requested by tokenLookup1 in\n    // handle_finalize. NULL if not found.\n    union extraInfo_t *item1;\n    // INPUT. Same as item1 but for tokenLookup2.\n    union extraInfo_t *item2;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext; // PLUGIN_CONTEXT_SIZE\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. Set by the plugin if it needs to display additional screens based\n    // on the information received from the token definitions.\n    uint8_t additionalScreens;  // Used by the plugin if it needs to display additional screens\n                                // based on the information received from the token definitions.\n\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    // - ETH_PLUGIN_RESULT_FALLBACK : if the signing logic should fallback to\n    // the generic one\n    eth_plugin_result_t result;\n\n} ethPluginProvideInfo_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_provide_token/#provided-token-structure","title":"Provided token structure","text":"<p>This is the structure given by the Ethereum application to the plugin.</p> <pre><code>// NFT\n\n#define COLLECTION_NAME_MAX_LEN 70\n\ntypedef struct nftInfo_t {\n    uint8_t contractAddress[ADDRESS_LENGTH];  // must be first item\n    char collectionName[COLLECTION_NAME_MAX_LEN + 1];\n} nftInfo_t;\n\n// TOKENS\n\n#define MAX_TICKER_LEN 51  // 50 characters + '\\0'\n\ntypedef struct tokenDefinition_t {\n    uint8_t address[ADDRESS_LENGTH];  // must be first item\n    char ticker[MAX_TICKER_LEN];\n    uint8_t decimals;\n} tokenDefinition_t;\n\n// UNION\n\ntypedef union extraInfo_t {\n    tokenDefinition_t token;\n// Would have used HAVE_NFT_SUPPORT but it is only declared for the Ethereum app\n// and not plugins\n#ifndef TARGET_NANOS\n    nftInfo_t nft;\n#endif\n} extraInfo_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_query_contract_id/","title":"handle_query_contract_id()","text":""},{"location":"technical_informations/handlers/handle_query_contract_id/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call this handle to query the contract name and version to display.</p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Write the name of the plugin/smart contract</li> <li>Write the version</li> </ul> <p>An example is already done in the boilerplate plugin. Adapt and expand it for your use case.</p>"},{"location":"technical_informations/handlers/handle_query_contract_id/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethQueryContractID_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n    // INPUT. Maximum possible name string length\n    size_t nameLength;\n    // INPUT. Maximum possible version string length\n    size_t versionLength;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext; // PLUGIN_CONTEXT_SIZE\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. Pointer to the name of the plugin\n    char *name;\n    // OUTPUT. Pointer to the version of the plugin\n    char *version;\n\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    eth_plugin_result_t result;\n\n} ethQueryContractID_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_query_contract_ui/","title":"handle_query_contract_ui()","text":""},{"location":"technical_informations/handlers/handle_query_contract_ui/#handle-explanation","title":"Handle explanation","text":"<p>The Ethereum application will call this handle for each screen to display if a custom UI was requested.</p> <p>The plugin needs to perform the following actions:</p> <ul> <li>Write the screen title for the current screen index</li> <li>Write the screen content for the current screen index</li> </ul> <p>An example is already done in the boilerplate plugin. Adapt and expand it for your use case.</p>"},{"location":"technical_informations/handlers/handle_query_contract_ui/#fields-descriptions","title":"Fields descriptions","text":"<pre><code>typedef struct ethQueryContractUI_s {\n    // ===== READ ONLY ===== //\n    // INPUT. Transaction data available to the plugin. READ-ONLY.\n    const txContent_t *txContent;\n\n    // INPUT. ERC20 token information as requested by tokenLookup1 in\n    // handle_finalize. NULL if not found.\n    union extraInfo_t *item1;\n    // INPUT. Same as item1 but for tokenLookup2.\n    union extraInfo_t *item2;\n\n    // INPUT. String that holds the network ticker\n    char network_ticker[MAX_TICKER_LEN];\n\n    // INPUT. Current screen to display.\n    uint8_t screenIndex;\n    // INPUT. Maximum possible title length\n    size_t titleLength;\n    // INPUT. Maximum possible msg length\n    size_t msgLength;\n\n    // ===== READ WRITE ===== //\n    // RW INPUT. Contains the semi-persistent RAM space that can be used by the\n    // plugin in each handle call.\n    uint8_t *pluginContext; // PLUGIN_CONTEXT_SIZE\n\n    // ===== WRITE ONLY ===== //\n    // OUTPUT. Pointer to the first line of the screen, to be filled by the\n    // plugin\n    char *title;\n    // OUTPUT. Pointer to the second line of he screen, to be filled by the\n    // plugin\n    char *msg;\n\n    // OUTPUT. Used by the plugin to inform the Ethereum application of the\n    // result of this handle The following return codes are expected, any other\n    // will abort the signing process:\n    // - ETH_PLUGIN_RESULT_OK\n    eth_plugin_result_t result;\n\n} ethQueryContractUI_t;\n</code></pre>"},{"location":"technical_informations/handlers/handle_query_contract_ui/#provided-token-structure","title":"Provided token structure","text":"<p>This is the structure given by the Ethereum application to the plugin.</p> <pre><code>// NFT\n\n#define COLLECTION_NAME_MAX_LEN 70\n\ntypedef struct nftInfo_t {\n    uint8_t contractAddress[ADDRESS_LENGTH];  // must be first item\n    char collectionName[COLLECTION_NAME_MAX_LEN + 1];\n} nftInfo_t;\n\n// TOKENS\n\n#define MAX_TICKER_LEN 51  // 50 characters + '\\0'\n\ntypedef struct tokenDefinition_t {\n    uint8_t address[ADDRESS_LENGTH];  // must be first item\n    char ticker[MAX_TICKER_LEN];\n    uint8_t decimals;\n} tokenDefinition_t;\n\n// UNION\n\ntypedef union extraInfo_t {\n    tokenDefinition_t token;\n// Would have used HAVE_NFT_SUPPORT but it is only declared for the Ethereum app\n// and not plugins\n#ifndef TARGET_NANOS\n    nftInfo_t nft;\n#endif\n} extraInfo_t;\n</code></pre>"},{"location":"technical_informations/utils/","title":"Utility functions","text":"<p>Utility functions are provided by the Ethereum Plugin SDK to help you code your plugin.</p> <p>They are complementary to the utility functions of the main SDK.</p>"},{"location":"technical_informations/utils/common_utils/","title":"common_utils.h","text":"<pre><code>// Number of decimal places in 1 Ether (or similar cryptocurrency) when\n// represented in Wei.\n#define WEI_TO_ETHER 18\n\n// The standard length of an Ethereum address\n#define ADDRESS_LENGTH 20\n\n// The length of a 128-bit integer in bytes\n#define INT128_LENGTH 16\n\n// The length of a 256-bit integer in bytes.\n#define INT256_LENGTH 32\n\n// The byte size of a Keccak-256 hash.\n#define KECCAK256_HASH_BYTESIZE 32\n\n// Hexadecimal digits for formatting and parsing purposes.\nstatic const char HEXDIGITS[] = \"0123456789abcdef\";\n\n// Computes the number of elements in an array.\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))\n\n/**\n * @brief Converts a binary value to a hexadecimal string representation.\n *\n * This function formats a binary value (represented by `value`) into a\n * hexadecimal string, prefixed with '0x'. The resulting string is stored in the\n * `out` buffer. The buffer should be large enough to accommodate the '0x'\n * prefix and the hexadecimal representation of the binary value.\n *\n * @param out A pointer to the buffer where the hexadecimal string will be\n * stored.\n * @param outl The length of the output buffer.\n * @param value A pointer to the binary value to be converted.\n * @param len The length of the binary value.\n * @return 0 on success, or -1 if an error occurs (e.g., buffer too small).\n */\nint array_bytes_string(char *out, size_t outl, const void *value, size_t len);\n\n/**\n * @brief Converts a big-endian byte array to a 64-bit unsigned integer.\n *\n * This function interprets the byte array `in` as a big-endian number and\n * converts it to a 64-bit unsigned integer. The conversion stops after `size`\n * bytes or when the input array has been fully processed.\n *\n * @param in A pointer to the byte array representing the big-endian number.\n * @param size The number of bytes to consider from the byte array.\n * @return The 64-bit unsigned integer representation of the byte array.\n */\nuint64_t u64_from_BE(const uint8_t *in, uint8_t size);\n\n/**\n * @brief Converts a 64-bit unsigned integer to a string.\n *\n * This function converts a 64-bit unsigned integer (`src`) to its decimal\n * string representation, storing the result in the `dst` buffer. The conversion\n * ensures that the resulting string is null-terminated and the buffer size\n * (`dst_size`) is sufficient to hold the result and the null terminator.\n *\n * @param src The 64-bit unsigned integer to convert.\n * @param dst A pointer to the buffer where the decimal string will be stored.\n * @param dst_size The size of the output buffer.\n * @return true if the conversion was successful and the output buffer contains\n * the resulting string, false if the buffer is too small or an error occurs.\n */\nbool u64_to_string(uint64_t src, char *dst, uint8_t dst_size);\n\n/**\n * @brief Converts a uint256 value to its decimal string representation.\n *\n * This function takes a uint256 value represented as a byte array, converts it\n * to a decimal string, and stores the result in the provided `out` buffer.\n * Leading zeros in the resulting decimal string are removed.\n *\n * @param value A pointer to the byte array representing the uint256 value.\n * @param value_len The length of the byte array `value`.\n * @param out A pointer to the buffer where the decimal string representation\n * will be stored.\n * @param out_len The length of the output buffer `out`.\n */\nbool uint256_to_decimal(const uint8_t *value,\n                        size_t value_len,\n                        char *out,\n                        size_t out_len);\n\n/**\n * @brief Converts an amount to its string representation with decimals and\n * ticker.\n *\n * This function takes a numeric amount represented as a byte array, converts it\n * to a decimal string, adjusts its decimal position according to the specified\n * number of decimals, and appends a ticker. The result is stored in the\n * `out_buffer`.\n *\n * @param amount A pointer to the byte array representing the amount.\n * @param amount_size The size of the amount byte array.\n * @param decimals The number of decimals to adjust to.\n * @param ticker A pointer to the ticker string to append to the amount.\n * @param out_buffer A pointer to the buffer where the resulting string will be\n * stored.\n * @param out_buffer_size The size of the output buffer.\n * @return true if the conversion and formatting were successful, false if the\n * output buffer is too small or an error occurs.\n */\nbool amountToString(const uint8_t *amount,\n                    uint8_t amount_len,\n                    uint8_t decimals,\n                    const char *ticker,\n                    char *out_buffer,\n                    size_t out_buffer_size);\n\n/**\n * @brief Adjusts the decimal position of a numeric string based on a specified\n * number of decimals.\n *\n * This function takes a numeric string `src` and adjusts its decimal position\n * according to the specified number of `decimals`, storing the result in the\n * `target` buffer. If the `src` string is shorter than the number of decimals,\n * leading zeros are added. Trailing zeros are removed from the result.\n *\n * @param src A pointer to the source numeric string.\n * @param srcLength The length of the source string.\n * @param target A pointer to the buffer where the adjusted string will be\n * stored.\n * @param targetLength The length of the target buffer.\n * @param decimals The number of decimals to adjust to.\n * @return true if the adjustment was successful and the target buffer contains\n * the resulting string, false if the target buffer is too small or an error\n * occurs.\n */\nbool adjustDecimals(const char *src,\n                    size_t srcLength,\n                    char *target,\n                    size_t targetLength,\n                    uint8_t decimals);\n\n/**\n * @brief Computes the Ethereum address from a raw public key.\n *\n * This function takes a 65-byte raw public key, computes its Keccak-256 hash,\n * and extracts the last 20 bytes as the Ethereum address.\n *\n * @param raw_pubkey A pointer to the raw public key (65 bytes).\n * @param out A pointer to the buffer where the 20-byte Ethereum address will be\n * stored.\n */\nvoid getEthAddressFromRawKey(const uint8_t raw_pubkey[static 65],\n                             uint8_t out[static ADDRESS_LENGTH]);\n\n/**\n * @brief Converts a raw public key to its Ethereum address string\n * representation.\n *\n * This function takes a 65-byte raw public key, computes its Keccak-256 hash,\n * extracts the last 20 bytes as the Ethereum address, and converts it to a\n * hexadecimal string with EIP-55 checksum, supporting EIP-1191 checksumming for\n * specific chain IDs.\n *\n * @param raw_pubkey A pointer to the raw public key (65 bytes).\n * @param out A pointer to the buffer where the checksum string representation\n * will be stored. The buffer must be at least (ADDRESS_LENGTH * 2) + 1 bytes\n * long.\n * @param chainId The chain ID to be used for EIP-1191 checksum (if applicable).\n */\nvoid getEthAddressStringFromRawKey(const uint8_t raw_pubkey[static 65],\n                                   char out[static(ADDRESS_LENGTH * 2) + 1],\n                                   uint64_t chainId);\n\n/**\n * @brief Converts a binary Ethereum address to its checksum string\n * representation.\n *\n * This function converts a binary Ethereum address to a hexadecimal string with\n * EIP-55 checksum. It supports EIP-1191 checksumming for specific chain IDs.\n *\n * @param address A pointer to the binary Ethereum address (20 bytes).\n * @param out A pointer to the buffer where the checksum string representation\n * will be stored. The buffer must be at least (ADDRESS_LENGTH * 2) + 1 bytes\n * long.\n * @param chainId The chain ID to be used for EIP-1191 checksum (if applicable).\n * @return true if the conversion was successful and the output buffer contains\n * the resulting string, false if an error occurs.\n */\nbool getEthAddressStringFromBinary(const uint8_t *address,\n                                   char out[static(ADDRESS_LENGTH * 2) + 1],\n                                   uint64_t chainId);\n\n/**\n * @brief Converts a binary Ethereum address to its lowercase string\n * representation.\n *\n * This function takes an Ethereum public key in binary format, converts it to a\n * lowercase hexadecimal string, and stores the result in the provided `out`\n * buffer. The resulting string will be null-terminated.\n *\n * @param in A pointer to the binary Ethereum public key.\n * @param out A pointer to the buffer where the lowercase string representation\n * will be stored. The buffer must be at least 43 bytes long.\n * @param out_len The length of the output buffer `out`.\n * @param chainId The chain ID to be used (for future compatibility or other\n * uses).\n * @return true if the conversion was successful and the output buffer contains\n * the resulting string, false if the output buffer is too small or an error\n * occurs.\n *\n * @example\n * uint8_t*:0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB -&gt;\n *      char*:\"0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB\\0\"\n */\nbool getEthDisplayableAddress(const uint8_t *in,\n                              char *out,\n                              size_t out_len,\n                              uint64_t chainId);\n\n/**\n * @brief Checks if a buffer is entirely filled with zeroes.\n *\n * This function examines the first `n` bytes of the buffer pointed to by `buf`\n * to determine if all bytes are zero.\n *\n * @param buf A pointer to the buffer to be checked.\n * @param n The number of bytes to check in the buffer.\n * @return 1 if all bytes in the buffer are zero, 0 otherwise.\n */\nint allzeroes(const void *buf, size_t n);\n\n/**\n * @brief Checks if a buffer is entirely filled with the maximum byte value\n * (0xff).\n *\n * This function examines the first `n` bytes of the buffer pointed to by `buf`\n * to determine if all bytes are equal to 0xff.\n *\n * @param buf A pointer to the buffer to be checked.\n * @param n The number of bytes to check in the buffer.\n * @return 1 if all bytes in the buffer are 0xff, 0 otherwise.\n */\nint ismaxint(const uint8_t *buf, int n);\n</code></pre>"},{"location":"technical_informations/utils/plugin_utils/","title":"plugin_utils.h","text":"<pre><code>// Size of a selector in bytes\n#define SELECTOR_SIZE 4\n\n// Length of a parameter in bytes\n#define PARAMETER_LENGTH 32\n\n/**\n * @brief Copies a portion of the parameter data to the destination buffer,\n * aligning the copy to the end.\n *\n * This function copies bytes from the `parameter` array to the `dst` buffer.\n * The number of bytes copied is determined by the smaller of `dst_size` and\n * `ADDRESS_LENGTH`. The copy starts from the end of the `parameter` array.\n *\n * @param dst A pointer to the destination buffer where the data will be copied.\n * @param parameter A pointer to the source data array.\n * @param dst_size The size of the destination buffer.\n */\nvoid copy_address(uint8_t *dst, const uint8_t *parameter, uint8_t dst_size);\n\n/**\n * @brief Copies a portion of the parameter data to the destination buffer.\n *\n * This function copies bytes from the `parameter` array to the `dst` buffer.\n * The number of bytes copied is determined by the smaller of `dst_size` and\n * `PARAMETER_LENGTH`.\n *\n * @param dst A pointer to the destination buffer where the data will be copied.\n * @param parameter A pointer to the source data array.\n * @param dst_size The size of the destination buffer.\n */\nvoid copy_parameter(uint8_t *dst, const uint8_t *parameter, uint8_t dst_size);\n\n/**\n * @brief Extracts a 16-bit unsigned integer from the parameter data if the rest\n * of the data is zero.\n *\n * This function checks if all bytes, except for the last 2 bytes of the\n * `parameter` array, are zero. If so, it extracts a 16-bit unsigned integer\n * from the end of the `parameter` array (in big-endian format) and stores it in\n * `value`.\n *\n * @param parameter A pointer to the parameter data array.\n * @param value A pointer to a 16-bit unsigned integer where the extracted value\n * will be stored.\n * @return true if the extraction was successful, false otherwise.\n */\nbool U2BE_from_parameter(const uint8_t *parameter, uint16_t *value);\n\n/**\n * @brief Extracts a 32-bit unsigned integer from the parameter data if the rest\n * of the data is zero.\n *\n * This function checks if all bytes, except for the last 4 bytes of the\n * `parameter` array, are zero. If so, it extracts a 32-bit unsigned integer\n * from the end of the `parameter` array (in big-endian format) and stores it in\n * `value`.\n *\n * @param parameter A pointer to the parameter data array.\n * @param value A pointer to a 32-bit unsigned integer where the extracted value\n * will be stored.\n * @return true if the extraction was successful, false otherwise.\n */\nbool U4BE_from_parameter(const uint8_t *parameter, uint32_t *value);\n\n/**\n * @brief Finds the index of a selector value in an array.\n *\n * This function searches for a specific selector value within an `array` of\n * `size` elements. If the selector is found, its index is stored in `idx` (if\n * not NULL), and the function returns true. Otherwise, it returns false.\n *\n * @param selector The value to search for in the array.\n * @param array A pointer to the array of selector values.\n * @param size The number of elements in the array.\n * @param idx A pointer to a size_t variable where the index of the found\n * selector will be stored (if not NULL).\n * @return true if the selector was found, false otherwise.\n */\nbool find_selector(uint32_t selector,\n                   const uint32_t *array,\n                   size_t size,\n                   size_t *idx);\n</code></pre>"},{"location":"test_framework/","title":"Test Framework","text":"<p>The folowing test elements are mandatory for your plugin:</p> <ul> <li>functionnal tests</li> <li>fuzzing</li> <li>CI</li> </ul> <p>A documentation page is provided here for each required element.</p> <p>This pages are extracted from the plugin-boilerplate sources.</p>"},{"location":"test_framework/ci/","title":"CI with Github workflows","text":"<p>The following Github workflows are provided for your application:</p>"},{"location":"test_framework/ci/#build_and_functional_testsyml","title":"build_and_functional_tests.yml","text":"<p>Example of full integration of the build system and Ragger testing tool in the CI. This workflow will run your functionnal tests and ensure they are passing on each pull-request.</p> <p>While this workflow itself is not mandatory, some form of functional tests in CI is mandatory.</p>"},{"location":"test_framework/ci/#cflite_cronyml-and-cflite_pryml","title":"cflite_cron.yml and cflite_pr.yml","text":"<p>This CIs will run the fuzzer tool on your plugin.</p> <p>This CIs are mandatory.</p>"},{"location":"test_framework/ci/#check_sdkyml","title":"check_sdk.yml","text":"<p>This CI will ensure that you are using the latest version of the Ethereum Plugin SDK.</p> <p>This CI is mandatory.</p>"},{"location":"test_framework/ci/#guidelines_enforceryml","title":"guidelines_enforcer.yml","text":"<p>This CI will perform checks to ensure that you meet the Ledger application guidelines.</p> <p>You can find more information here</p> <p>This CI is mandatory.</p>"},{"location":"test_framework/ci/#lint-workflowyml","title":"lint-workflow.yml","text":"<p>This CI will ensure that your application is properly linted.</p> <p>While this CI is mandatory, the content of the <code>.clang-format</code> file is not and you can tweak it to your liking.</p>"},{"location":"test_framework/fuzzing/","title":"Fuzzing on transaction parser","text":"<p>Fuzzing allows us to test how a program behaves when provided with invalid, unexpected, or random data as input.</p> <p>In the case of <code>app-plugin-boilerplate</code> we want to test the code that is responsible for handling the contract data. The fuzzer needs to implement <code>int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)</code>, which provides an array of random bytes that can be used to simulate a serialized transaction. If the application crashes, or a sanitizer detects any kind of access violation, the fuzzing process is stopped, a report regarding the vulnerability is shown, and the input that triggered the bug is written to disk under the name <code>crash-*</code>. The vulnerable input file created can be passed as an argument to the fuzzer to triage the issue.</p> <p>Note: Usually we want to write a separate fuzz target for each functionality.</p>"},{"location":"test_framework/fuzzing/#manual-usage-based-on-ledger-container","title":"Manual usage based on Ledger container","text":""},{"location":"test_framework/fuzzing/#preparation","title":"Preparation","text":"<p>Before being able to use the fuzzing tests, the environment must be prepared with all submodules. To install them, use the following command in the repository root directory:</p> <pre><code>git submodule update --init\n</code></pre> <p>The fuzzer can run from the docker <code>ledger-app-builder-legacy</code>. You can download it from the <code>ghcr.io</code> docker repository:</p> <pre><code>sudo docker pull ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre> <p>You can then enter this development environment by executing the following command from the repository root directory:</p> <pre><code>sudo docker run --rm -ti --user \"$(id -u):$(id -g)\" -v \"$(realpath .):/app\" ghcr.io/ledgerhq/ledger-app-builder/ledger-app-builder-legacy:latest\n</code></pre>"},{"location":"test_framework/fuzzing/#compilation","title":"Compilation","text":"<p>Once in the container, go into the <code>fuzzing</code> folder to compile the fuzzer:</p> <pre><code>cd fuzzing\n\n# cmake initialization\ncmake -DBOLOS_SDK=/opt/nanox-secure-sdk -DCMAKE_C_COMPILER=/usr/bin/clang -Bbuild -H.\n\n# Fuzzer compilation\nmake -C build\n</code></pre>"},{"location":"test_framework/fuzzing/#run","title":"Run","text":"<pre><code>./build/fuzz\n</code></pre>"},{"location":"test_framework/fuzzing/#full-usage-based-on-clusterfuzzlite-container","title":"Full usage based on <code>clusterfuzzlite</code> container","text":"<p>Exactly the same context as the CI, directly using the <code>clusterfuzzlite</code> environment.</p> <p>More info can be found here: https://google.github.io/clusterfuzzlite/</p>"},{"location":"test_framework/fuzzing/#preparation_1","title":"Preparation","text":"<p>The principle is to build the container, and run it to perform the fuzzing.</p> <p>Note: The container contains a copy of the sources (they are not cloned), which means the <code>docker build</code> command must be re-executed after each code modification.</p> <pre><code># Prepare directory tree\nmkdir fuzzing/{corpus,out}\n# Container generation\ndocker build -t app-plugin-boilerplate --file .clusterfuzzlite/Dockerfile .\n</code></pre>"},{"location":"test_framework/fuzzing/#compilation_1","title":"Compilation","text":"<pre><code>docker run --rm --privileged -e FUZZING_LANGUAGE=c -v \"$(realpath .)/fuzzing/out:/out\" -ti app-plugin-boilerplate\n</code></pre>"},{"location":"test_framework/fuzzing/#run_1","title":"Run","text":"<pre><code>docker run --rm --privileged -e FUZZING_ENGINE=libfuzzer -e RUN_FUZZER_MODE=interactive -v \"$(realpath .)/fuzzing/corpus:/tmp/fuzz_corpus\" -v \"$(realpath .)/fuzzing/out:/out\" -ti gcr.io/oss-fuzz-base/base-runner run_fuzzer fuzz\n</code></pre>"},{"location":"test_framework/ragger/","title":"Functional tests","text":"<p>The tests craft APDUs, send them to the application, and assert the RAPDUs results and the screen content. You will need to adapt / enrich the test database with tests relevant to your plugin. The presence of functional testing of your plugin and an associated CI is mandatory.</p>"},{"location":"test_framework/ragger/#tools-used","title":"Tools used","text":"<ul> <li>The Speculos tool is used to emulate the device and its applications.</li> <li>The Ragger test framework (pytest based) is used to manage the Speculos instance and provide useful helper functions (APDU exchanges, screen navigation, etc).</li> <li>The Ledger VSCode extension can optionnaly be used to compile the application and run the tests. This documentation will describe using the <code>VSCode extension</code> and <code>bash</code> command lines.</li> <li>The Ledger Ethereum client (Web3 based) can be used to craft the smart contract transactions.</li> </ul> <p>This frameworks are developed by Ledger, if you have trouble using them, we invite you to get in touch with us on our Discord. The usage of the Ragger framework for your tests is greatly recommended.</p>"},{"location":"test_framework/ragger/#compiling-the-binaries","title":"Compiling the binaries","text":"<p>In order to run the tests you need to provide the binaries for both the plugin and the Ethereum application.</p>"},{"location":"test_framework/ragger/#plugin-binaries","title":"Plugin binaries","text":"<p>Compiling the plugin will produce the binary for the targeted device. They will be used in-place by the test framework.</p>"},{"location":"test_framework/ragger/#ethereum-binaries","title":"Ethereum binaries","text":"<p>The binaries of the Ethereum application must be gathered and placed in the directory <code>tests/.test_dependencies/ethereum/</code> of your plugin.</p> <p>Example of the correct file tree with Ethereum compiled for all targets: <pre><code>$ tree -a -L 3 .test_dependencies/\n.test_dependencies/\n\u2514\u2500\u2500 ethereum\n    \u251c\u2500\u2500 .ethereum_application_build_goes_there\n    \u2514\u2500\u2500 build\n        \u251c\u2500\u2500 flex\n        \u251c\u2500\u2500 apex_p\n        \u251c\u2500\u2500 nanos\n        \u251c\u2500\u2500 nanos2\n        \u251c\u2500\u2500 nanox\n        \u2514\u2500\u2500 stax\n</code></pre></p> <p>Several methods are available:</p> <ul> <li>Use the Ledger VSCode extension to automatically manage dependencies.</li> <li>Clone the Ethereum application in the <code>.test_dependencies/</code> directory and compile it.<ul> <li>You will need to set the compilation flags manually to compile for tests.</li> <li>Open the Ethereum application manifest and use the flags from <code>use_test_keys</code></li> </ul> </li> <li>Re-use the Ethereum build produced by a test CI, and available as artifact. Example here with the plugin-boilerplate CI.</li> </ul>"},{"location":"test_framework/ragger/#launching-the-tests","title":"Launching the tests","text":"<p>The plugin boilerplate application comes with some template functional tests.</p>"},{"location":"test_framework/ragger/#macos-windows","title":"macOS / Windows","text":"<p>To test your application on macOS or Windows, it is recommended to use Ledger VSCode extension to quickly setup a working test environment.</p> <p>You can use the following task (accessible in the extension sidebar menu) :</p> <ul> <li>Use <code>Run tests</code>.</li> </ul>"},{"location":"test_framework/ragger/#linux-ubuntu","title":"Linux (Ubuntu)","text":"<p>On Linux, you can use Ledger VSCode extension to run the tests.</p> <p>Alternatively, you can run the test by command lines in your terminal.</p> <p>Install the tests requirements (only needed once):</p> <pre><code>pip install -r tests/requirements.txt\n</code></pre> <p>Run the tests. For example, run the following command to run all tests on all devices:</p> <pre><code>pytest -v tests/ --device all\n</code></pre> <p>Please refer to the Ragger repository for a documentation on the many parameters and features offered by the framework.</p>"},{"location":"test_framework/ragger/#developing-your-tests","title":"Developing your tests","text":"<p>The test provided in <code>test_swap.py</code> is a simple test of a successful parsing, display, and signature of smart contract <code>swapExactETHForTokens</code>.</p> <p>When forking the boilerplate to develop your own plugin, you will need to adapt the tests to use your own smart contract.</p>"},{"location":"test_framework/ragger/#using-the-ledger-ethereum-client","title":"Using the Ledger Ethereum client","text":"<p>The Ledger Ethereum client is a Python module that abstracts the APDU crafting and response parsing. It comes from the Ethereum app itself and is what's used to test it in its CI. Conveniently, it also has everything needed for testing plugins.</p>"},{"location":"test_framework/ragger/#cal-signature-mock","title":"CAL signature mock","text":"<p>This module supports the official Ethereum appplication test signing keys, so that APDUs that are signed by the Ledger backend CAL in production can be mocked during the tests.</p> <p>The Ethereum application must be compiled with the test keys flags. Please refer to the Ethereum application compilation section to know more about this.</p>"},{"location":"test_framework/ragger/#abis","title":"ABIs","text":"<p>The Ethereum Ragger client relies on the Web3 python module for transaction crafting and it can leverage a smart contract's ABI (Application Binary Interface) to craft contracts. ABIs are obtainable from a website like Etherscan for example.</p>"},{"location":"test_framework/ragger/#signature-verification","title":"Signature verification","text":"<p>The Ragger client can also easily verify a transaction's signature by recovering the Ethereum address of the wallet that signed the transaction. Testing the UI is crucial but so is testing the signatures we produce.</p>"},{"location":"walkthrough/","title":"Walkthrough overview","text":"<p>This page will walk you through developing your plugin, from the Boilerplate fork to the functional tests. Sections of the template code you can edit are commented with a <code>EDIT THIS</code> marker.</p>"},{"location":"walkthrough/#change-the-plugin-metadata","title":"Change the plugin metadata","text":"<p>In the <code>Makefile</code> you will need to change the following elements:</p> <ul> <li><code>APPNAME</code> to suit your plugin name (e.g., Paraswap, 1inch, Lido)</li> <li><code>APPVERSION</code> for your plugin version</li> </ul>"},{"location":"walkthrough/#change-the-plugin-icons","title":"Change the plugin icons","text":"<p>In the <code>icons/</code> and <code>glyphs/</code> directory, rename the images to include your <code>APPNAME</code> instead of the <code>pluginboilerplate</code> name. Change the picture provided to use one suitable for your plugin. Don't forget to refer to the documentation. Incompatible icons will be detected by the CI.</p>"},{"location":"walkthrough/#change-the-selectors","title":"Change the selectors","text":"<p>Let\u2019s go to the first <code>EDIT THIS</code> comment in <code>app-plugin-boilerplate/src/plugin.h</code>. In this file you can list all the selectors for each contract. The template uses uses two selectors but you are not limited.  Enter your selectors here, in the format X(NAME, value).</p>"},{"location":"walkthrough/#example-lets-support-swapexactethfortoken-from-uniswap-v2","title":"Example: Let's support <code>SwapExactEthForToken</code> from Uniswap V2","text":"<p>You can find it using Etherscan, and you can also compose it using the ABI (Application Binary Interface).</p> <p>By looking at recent transactions on Uniswap, we find a transaction with the <code>SwapExactEthForToken</code> method. Here is an example.</p> <p>Let's scroll down and click on \"Click to see more\", to read:</p> <p></p> <p>The header line shows <code>Method ID</code> to be <code>0x7ff36ab5</code>. This is going to be the 4 bytes of <code>SWAP_EXACT_ETH_FOR_TOKENS_SELECTOR</code>:</p> <pre><code>#define SELECTORS_LIST(X)                    \\\n    X(SWAP_EXACT_ETH_FOR_TOKENS_SELECTOR, 0x7ff36ab5)\n</code></pre>"},{"location":"walkthrough/#update-the-plugin_specificationmd-file","title":"Update the <code>PLUGIN_SPECIFICATION.md</code> file","text":"<p>Please update the <code>PLUGIN_SPECIFICATION.md</code> file at the root of the project to include your smart contract and selectors.</p>"},{"location":"walkthrough/#adapt-the-handlers","title":"Adapt the handlers","text":"<p>Now we have to change each handler to parse and display your smart contract.</p> <p>We advise you to stick to the file structure done in plugin-boilerplate and keep each handler in a dedicated file.</p> <p>Please look at the sequence diagram to better understand at which step each handler is called.</p>"}]}